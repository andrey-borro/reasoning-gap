{"messages": [{"role": "user", "content": [{"text": "You will be given a PDDL domain, as well as an example problem and solution for that domain. Your goal is to write a strategy for the domain which will be used as part of a prompt for a weaker LLM to solve this problem. The strategy should be threefold. \n\n---\nFirstly, a brief overview of the high-level dynamics, e.g. how the actions interact and what they are used for in the domain. Do not just repeat the preconditions and effects in PDDL - the LLM will have access to these. Instead, use English to explain the environment and how the actions are used to do things in it. Finish this overview with a brief list of key constraints about objects within this environment (see example).\n\nSecondly, a high-level guide to solving a general problem within this domain. The guide should open with \"To solve the problem, follow these step-by-step instructions:\". Follow this with an instruction step outlining how to interpret the goal configuration in the context of planning your solution. After this, give simple and clear instructions on how to solve the task, step-by-step. Remember that you are talking to an LLM. It has no memory or space to \"visualise\" a problem, nor does it respond well to being philosophical. Instead, give clear and very simple actionable instructions for it to follow. Each instruction should represent a \"big picture\" step for the agent to follow. Then, explain how to achieve that step in sub-instructions. Absolutely prioritise the most simple (to understand and follow) instructions, even if it means having a longer solution. Do not forget that the LLM executing this is weak, and should not try to do complex reasoning if it can be avoided. Your job is to do as much of the thinking as you can, and to give it clear steps to take action on.\n\nThirdly, give a list (at most five) of common mistakes that you assume a weaker LLM is likely to make and how to avoid them. Prioritise the ones that you think might be most likely to stump the LLM. \n\nThroughout the strategy, feel free to use general examples (but keep them very short and concise, as they should not take up much of the strategy at all).\n\n---\n\nA (slightly less detailed than you should aim for) example for the gripper domain could look like:\n\nDomain Overview:\nThe domain consists of balls (e.g. balla, ballb, ballc) in rooms (rooma, roomb ....), with a robot that travels between the two rooms. The robot can only pick up to two balls at a time using the pickup action - one in each hand, specified as part of the action e.g. (pickup balla rooma left), and only when they are with him in the room that he is currently on. The robot moves between rooms using the move action, taking the balls in his hands with him, and dropping a ball will drop it into the room that the robot is currently in. \n\nKey Contstraints\n - the robot can hold at most 2 balls\n - balls must be in the same room as the robot to be picked up\n- the robot must have a free hand to pick up a ball\n\nSolution Overview:\nTo solve the problem, follow these step-by-step instructions:\n1. Observe the required goal location for the balls e.g. (at roomb balla)\n2. Move the robot to the location of a ball that needs to move\n- ensure that it has dropped off whichever balls it was moving prior\n3. pick up the ball, as well as any other ball (if any) that is in the same room and needs to go to the same destination room\n- (short example)\n4. move the robot to the destination room and drop whichever balls it is holding and need to be in that room\n5. repeat this process until all balls are where they need to be, tracking which balls remain\n\nCommon Mistakes:\nDo not pick up balls once they are in the room where they need to be, they do not need to be touched again. \nDo not try and pick up balls if they are in different rooms, the robot can only pick up balls in the same room. \netc. \n\n---\n\nThe PDDL domain that you are writing the strategy for:\naction : pickup (block)\npreconds : (clear block), (ontable block), (handempty)\neffects : (holding block), not(ontable block), not(clear block), not(handempty)\n\naction : putdown (block)\npreconds : (holding block)\neffects : not(holding block), (clear block), (ontable block), (handempty)\n\naction : unstack (top-block bottom-block)\npreconds : (on top-block bottom-block), (clear top-block), (handempty)\neffects : (holding top-block), (clear bottom-block), not(on top-block bottom-block), not(clear bottom-block), not(handempty)\n\naction : stack (top-block bottom-block)\npreconds : (holding top-block), (clear bottom-block)\neffects : (on top-block bottom-block), (clear top-block), (handempty), not(holding top-block), not(clear bottom-block)\nHere is an example problem within this domain:\n\nInitial State:\n(clear a)\n(clear d)\n(handempty)\n(on a b)\n(on d c)\n(ontable b)\n(ontable c)\n\nGoal:\n(on a b)\n(on b c)\n(on c d)\n\nSolution:\n(unstack d c)\n(putdown d)\n(pickup c)\n(stack c d)\n(unstack a b)\n(putdown a)\n(pickup b)\n(stack b c)\n(pickup a)\n(stack a b)\n", "type": "text"}]}], "response": {"content": "Domain Overview:\n\nIn this domain, we work with a set of blocks that can be stacked on top of each other or placed on a table. The goal is to rearrange the blocks to match a specific configuration. You can manipulate the blocks one at a time using a robotic arm (the agent) that can hold only one block at a time.\n\nAvailable actions to manipulate the blocks:\n\n1. **Pickup (block)**: Pick up a clear block from the table when the agent's hand is empty.\n2. **Putdown (block)**: Place a block the agent is holding onto the table.\n3. **Unstack (top-block, bottom-block)**: Remove a clear top block from a stack when the agent's hand is empty.\n4. **Stack (top-block, bottom-block)**: Place a block the agent is holding onto a clear bottom block to form a stack.\n\nKey Constraints:\n\n- The agent can hold only one block at a time.\n- A block must be clear (no blocks on top of it) to be picked up, unstacked, or have another block stacked onto it.\n- The agent's hand must be empty to pick up or unstack a block.\n- To stack a block onto another, the block being stacked onto must be clear.\n\nSolution Overview:\n\nTo solve the problem, follow these step-by-step instructions:\n\n1. **Understand the Goal Configuration**:\n   - **Identify** each block and determine where it needs to be in the final arrangement.\n   - **Note** the desired stacking order from bottom to top as specified in the goal.\n\n2. **Plan the Stacking Sequence from Bottom to Top**:\n   - **List** the blocks in the order they need to be stacked, starting with the bottom block.\n   - **Ensure** you know which blocks need to be moved and which are already in the correct position.\n\n3. **Prepare the Bottom Block(s)**:\n   - For each bottom block in the desired stack:\n     - a. **Locate** the block.\n     - b. If the block is not on the table:\n        - **Unstack** it from any block below using the `unstack` action.\n        - **Put it down** on the table using the `putdown` action.\n     - c. **Make sure** the block is clear by removing any blocks on top:\n        - If there are blocks on top, **unstack** them and **put them down** on the table.\n\n4. **Stack Each Block in Order**:\n   - For each subsequent block in your stacking sequence:\n     - a. **Ensure the block to move is clear**:\n        - If there are blocks on top, **unstack** them and **put them down** on the table.\n     - b. **Ensure the target block (the one to stack onto) is clear**:\n        - If it is not clear, **unstack** any blocks on top and **put them down** on the table.\n     - c. **Pick up the block**:\n        - If the block is on the table and clear, use the `pickup` action.\n        - If the block is on another block and clear, use the `unstack` action.\n     - d. **Stack the block onto the target block** using the `stack` action.\n\n5. **Repeat Until All Blocks Are Stacked Correctly**:\n   - **Continue** stacking each block in order, following steps 4a to 4d for each one.\n   - **Verify** after each action that the blocks are in the correct intermediate configuration towards the goal.\n\n6. **Check That the Goal State Is Achieved**:\n   - **Compare** the current configuration of blocks with the goal configuration.\n   - **Confirm** that each block is in the correct position and order.\n\nCommon Mistakes:\n\n1. **Not Clearing Blocks Before Moving Them**:\n   - Always ensure a block is clear (no blocks on top) before attempting to pick it up or unstack it.\n\n2. **Forgetting to Clear the Target Block Before Stacking Onto It**:\n   - Make sure the block you want to stack onto is clear before stacking.\n\n3. **Not Emptying the Agent's Hand Before Picking Up a New Block**:\n   - Remember that the agent must have an empty hand to pick up or unstack a block.\n\n4. **Stacking Blocks in the Wrong Order**:\n   - Follow the planned stacking sequence strictly from bottom to top to avoid misplacement.\n\n5. **Ignoring Blocks Not Involved in the Final Stack**:\n   - Move unnecessary blocks out of the way by placing them on the table so they don't interfere with stacking.", "model": "o1-preview-2024-09-12", "output_tokens": 971, "input_tokens": 1261, "reasoning_tokens": 3072}}